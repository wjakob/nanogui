# This file is executed at build time before all other NanoGUI targets are built
# (e.g., nanogui-obj and nanogui-python-obj).  The expected arguments are:
#
# NANOGUI_BIN2C_OUTPUT_C:    the source file to generate
# NANOGUI_BIN2C_OUTPUT_H:    the header file to generate
# NANOGUI_BIN2C_INPUT_FILES: the comma separated list of .ttf files to process
#
# See ../CMakeLists.txt, searching for `add_custom_command`, to see how this
# script can be used.

# Create header for C file
file(WRITE ${NANOGUI_BIN2C_OUTPUT_C} "/* Autogenerated by bin2c */

#include <nanogui/resources.h>
#include <nanovg.h>
#include <map>
#include <string>
#include <stdint.h>

NAMESPACE_BEGIN(nanogui)

")

# Create the full header file
file(WRITE ${NANOGUI_BIN2C_OUTPUT_H} "/* Autogenerated by bin2c */

#pragma once

#include <nanogui/common.h>
NAMESPACE_BEGIN(nanogui)

/* Pass-through method to call ``nvgCreateFontMem``.
 *
 * Parameters:
 *     - ctx: the NanoVG context (included in nanogui::Theme constructor).
 *     - fontName: the name to register (e.g., \"sans\" or \"sans-bold\").
 *     - fontSource: the *basename* of the font source (e.g., \"Roboto-Regular.ttf\").
 */
extern NANOGUI_EXPORT int createFontMem(NVGcontext *ctx, const std::string &fontName, const std::string &fontSource);

NAMESPACE_END(nanogui)
")

# Iterate through binary font files
# Transform comma separated command-line input back to semicolon separated CMake list
string(REPLACE "," ";" NANOGUI_BIN2C_INPUT_FILES "${NANOGUI_BIN2C_INPUT_FILES}")
# Counter setup for populating FONT_MAP_DECL / FONT_MAP_DECL_PART
list(LENGTH NANOGUI_BIN2C_INPUT_FILES NUM_FONTS)
set(FONT_COUNTER 0)
math(EXPR LAST_FONT_INDEX "${NUM_FONTS} - 1")
foreach(bin ${NANOGUI_BIN2C_INPUT_FILES})
  # Get short filename
  string(REGEX MATCH "([^/]+)$" filename ${bin})
  # Save short filename for static map key entries
  set(orig_filename ${filename})
  # script calling this informs status of processing font resources, indent underneath
  message(STATUS "Generating font resource: ${orig_filename}")
  # Replace filename spaces & extension separator for C compatibility
  string(REGEX REPLACE "\\.| |-" "_" filename ${filename})
  # Convert to lower case
  string(TOLOWER ${filename} filename)
  # Read hex data from file
  file(READ ${bin} filedata HEX)
  # Convert hex data for C compatibility
  string(REGEX REPLACE "([0-9a-f][0-9a-f])" "0x\\1," filedata ${filedata})
  # Append data to c file
  file(APPEND ${NANOGUI_BIN2C_OUTPUT_C} "uint8_t ${filename}[] = {${filedata}};\n\n")
  file(APPEND ${NANOGUI_BIN2C_OUTPUT_C} "uint32_t ${filename}_size = sizeof(${filename});\n\n")
  # Accumulate the static font map declaration string (written at end after loop)
  set(FONT_MAP_DECL_PART "    {\"${orig_filename}\", {${filename}, ${filename}_size}}")
  if (FONT_COUNTER LESS LAST_FONT_INDEX)
    set(FONT_MAP_DECL_PART "${FONT_MAP_DECL_PART},") # add comma if not last item
  endif()
  list(APPEND FONT_MAP_DECL "${FONT_MAP_DECL_PART}\n")
  math(EXPR FONT_COUNTER "${FONT_COUNTER} + 1")
endforeach()

# Create the static map of font filenames to the generated resources
# filename -> {uint8_t * [the embedded font], uint32_t [the sizeof the embedded font]}
file(APPEND ${NANOGUI_BIN2C_OUTPUT_C} "std::map<const std::string, const std::pair<uint8_t *, uint32_t>> __nanogui_font_map = {\n")
foreach(part ${FONT_MAP_DECL})
  file(APPEND ${NANOGUI_BIN2C_OUTPUT_C} "${part}")
endforeach()
file(APPEND ${NANOGUI_BIN2C_OUTPUT_C} "};\n\n")

# Create the implementation of `createFontMem` to pass-through to `nvgCreateFontMem`
file(APPEND ${NANOGUI_BIN2C_OUTPUT_C} "int createFontMem(NVGcontext *ctx, const std::string &fontName, const std::string &fontSource) {
    if (__nanogui_font_map.count(fontSource) > 0) {
        const auto &p = __nanogui_font_map[fontSource];
        return nvgCreateFontMem(ctx, fontName.c_str(), p.first, p.second, 0);
    }
    return -1;// signals error
}

NAMESPACE_END(nanogui)

")
